#include "core.h"
#include "video.h"
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <stdio.h>
#include <fcntl.h>

static uint8_t* color_buffer;
static uint8_t* character_buffer;

// Video mode control word
#define MAKEVMODEINFO(_cmode, _vmode, _scanEnable) ((_cmode&0x1)<<2) | ((_vmode&0x1)<<1) | (_scanEnable&0x1)

static const uint8_t residentfont[] __attribute__((aligned(16))) = {
0x00, 0xe7, 0xe7, 0xc6, 0x01, 0x83, 0x01, 0x00, 0xff, 0x00, 0xff, 0xf0, 0xc3, 0xf3, 0xf7, 0x81, 
0x00, 0x18, 0xff, 0xef, 0x83, 0xc7, 0x83, 0x00, 0xff, 0xc3, 0x3c, 0x70, 0x66, 0x33, 0x36, 0xbd, 
0x00, 0x5a, 0xbd, 0xef, 0xc7, 0x83, 0xc7, 0x81, 0x7e, 0x66, 0x99, 0xf0, 0x66, 0xf3, 0xf7, 0xc3, 
0x00, 0x18, 0xff, 0xef, 0xef, 0xef, 0xef, 0xc3, 0x3c, 0x24, 0xdb, 0xd7, 0x66, 0x03, 0x36, 0x7e, 
0x00, 0xdb, 0x3c, 0xc7, 0xc7, 0xef, 0xef, 0xc3, 0x3c, 0x24, 0xdb, 0xcc, 0xc3, 0x03, 0x36, 0x7e, 
0x00, 0x99, 0x7e, 0x83, 0x83, 0x6d, 0xc7, 0x81, 0x7e, 0x66, 0x99, 0xcc, 0x81, 0x07, 0x76, 0xc3, 
0x00, 0x18, 0xff, 0x01, 0x01, 0x01, 0x01, 0x00, 0xff, 0xc3, 0x3c, 0xcc, 0xe7, 0x0f, 0x6e, 0xbd, 
0x00, 0xe7, 0xe7, 0x00, 0x00, 0x83, 0x83, 0x00, 0xff, 0x00, 0xff, 0x87, 0x81, 0x0e, 0x0c, 0x81, 
0x08, 0x20, 0x81, 0x66, 0xf7, 0xe3, 0x00, 0x81, 0x81, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x0e, 0xe0, 0xc3, 0x66, 0xbd, 0x16, 0x00, 0xc3, 0xc3, 0x81, 0x81, 0x03, 0x00, 0x42, 0x81, 0xff, 
0x8f, 0xe3, 0xe7, 0x66, 0xbd, 0xc3, 0x00, 0xe7, 0xe7, 0x81, 0xc0, 0x06, 0x0c, 0x66, 0xc3, 0xff, 
0xef, 0xef, 0x81, 0x66, 0xb7, 0x66, 0x00, 0x81, 0x81, 0x81, 0xef, 0xef, 0x0c, 0xff, 0xe7, 0xe7, 
0x8f, 0xe3, 0x81, 0x66, 0xb1, 0x66, 0xe7, 0xe7, 0x81, 0xe7, 0xc0, 0x06, 0x0c, 0x66, 0xff, 0xc3, 
0x0e, 0xe0, 0xe7, 0x00, 0xb1, 0xc3, 0xe7, 0xc3, 0x81, 0xc3, 0x81, 0x03, 0xef, 0x42, 0xff, 0x81, 
0x08, 0x20, 0xc3, 0x66, 0xb1, 0x68, 0xe7, 0x81, 0x81, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x81, 0x00, 0x00, 0xc7, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x81, 0x66, 0xc6, 0x81, 0x00, 0x83, 0x81, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 
0x00, 0xc3, 0x66, 0xc6, 0xe3, 0x6c, 0xc6, 0x81, 0x81, 0x81, 0x66, 0x81, 0x00, 0x00, 0x00, 0xc0, 
0x00, 0xc3, 0x42, 0xef, 0x06, 0xcc, 0x83, 0x03, 0x03, 0xc0, 0xc3, 0x81, 0x00, 0x00, 0x00, 0x81, 
0x00, 0x81, 0x00, 0xc6, 0xc3, 0x81, 0x67, 0x00, 0x03, 0xc0, 0xff, 0xe7, 0x00, 0xe7, 0x00, 0x03, 
0x00, 0x81, 0x00, 0xef, 0x60, 0x03, 0xcd, 0x00, 0x03, 0xc0, 0xc3, 0x81, 0x00, 0x00, 0x00, 0x06, 
0x00, 0x00, 0x00, 0xc6, 0xc7, 0x66, 0xcc, 0x00, 0x81, 0x81, 0x66, 0x81, 0x81, 0x00, 0x81, 0x0c, 
0x00, 0x81, 0x00, 0xc6, 0x81, 0x6c, 0x67, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x81, 0x00, 0x81, 0x08, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
0x83, 0x81, 0xc7, 0xc7, 0xc1, 0xef, 0x83, 0xef, 0xc7, 0xc7, 0x00, 0x00, 0x60, 0x00, 0x06, 0xc7, 
0xc6, 0x83, 0x6c, 0x6c, 0xc3, 0x0c, 0x06, 0x6c, 0x6c, 0x6c, 0x81, 0x81, 0xc0, 0x00, 0x03, 0x6c, 
0x6c, 0x81, 0x60, 0x60, 0xc6, 0x0c, 0x0c, 0xc0, 0x6c, 0x6c, 0x81, 0x81, 0x81, 0xe7, 0x81, 0xc0, 
0x6d, 0x81, 0xc1, 0xc3, 0xcc, 0xcf, 0xcf, 0x81, 0xc7, 0xe7, 0x00, 0x00, 0x03, 0x00, 0xc0, 0x81, 
0x6c, 0x81, 0x03, 0x60, 0xef, 0x60, 0x6c, 0x03, 0x6c, 0x60, 0x00, 0x00, 0x81, 0x00, 0x81, 0x81, 
0xc6, 0x81, 0x66, 0x6c, 0xc0, 0x6c, 0x6c, 0x03, 0x6c, 0xc0, 0x81, 0x81, 0xc0, 0xe7, 0x03, 0x00, 
0x83, 0xe7, 0xef, 0xc7, 0xe1, 0xc7, 0xc7, 0x03, 0xc7, 0x87, 0x81, 0x81, 0x60, 0x00, 0x06, 0x81, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
0xc7, 0x83, 0xcf, 0xc3, 0x8f, 0xef, 0xef, 0xc3, 0x6c, 0xc3, 0xe1, 0x6e, 0x0f, 0x6c, 0x6c, 0xc7, 
0x6c, 0xc6, 0x66, 0x66, 0xc6, 0x26, 0x26, 0x66, 0x6c, 0x81, 0xc0, 0x66, 0x06, 0xee, 0x6e, 0x6c, 
0xed, 0x6c, 0x66, 0x0c, 0x66, 0x86, 0x86, 0x0c, 0x6c, 0x81, 0xc0, 0xc6, 0x06, 0xef, 0x6f, 0x6c, 
0xed, 0xef, 0xc7, 0x0c, 0x66, 0x87, 0x87, 0x0c, 0xef, 0x81, 0xc0, 0x87, 0x06, 0xef, 0xed, 0x6c, 
0xed, 0x6c, 0x66, 0x0c, 0x66, 0x86, 0x86, 0xec, 0x6c, 0x81, 0xcc, 0xc6, 0x26, 0x6d, 0xec, 0x6c, 
0x0c, 0x6c, 0x66, 0x66, 0xc6, 0x26, 0x06, 0x66, 0x6c, 0x81, 0xcc, 0x66, 0x66, 0x6c, 0x6c, 0x6c, 
0x87, 0x6c, 0xcf, 0xc3, 0x8f, 0xef, 0x0f, 0xa3, 0x6c, 0xc3, 0x87, 0x6e, 0xef, 0x6c, 0x6c, 0xc7, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xcf, 0xc7, 0xcf, 0xc3, 0xe7, 0x6c, 0x6c, 0x6c, 0x6c, 0x66, 0xef, 0xc3, 0x0c, 0xc3, 0x01, 0x00, 
0x66, 0x6c, 0x66, 0x66, 0xe7, 0x6c, 0x6c, 0x6c, 0x6c, 0x66, 0x6c, 0x03, 0x06, 0xc0, 0x83, 0x00, 
0x66, 0x6c, 0x66, 0x03, 0xa5, 0x6c, 0x6c, 0x6c, 0xc6, 0x66, 0xc8, 0x03, 0x03, 0xc0, 0xc6, 0x00, 
0xc7, 0x6c, 0xc7, 0x81, 0x81, 0x6c, 0x6c, 0x6d, 0x83, 0xc3, 0x81, 0x03, 0x81, 0xc0, 0x6c, 0x00, 
0x06, 0x6c, 0xc6, 0xc0, 0x81, 0x6c, 0x6c, 0x6d, 0xc6, 0x81, 0x23, 0x03, 0xc0, 0xc0, 0x00, 0x00, 
0x06, 0xec, 0x66, 0x66, 0x81, 0x6c, 0xc6, 0xef, 0x6c, 0x81, 0x66, 0x03, 0x60, 0xc0, 0x00, 0x00, 
0x0f, 0xc7, 0x6e, 0xc3, 0xc3, 0xc7, 0x83, 0xc6, 0x6c, 0xc3, 0xef, 0xc3, 0x20, 0xc3, 0x00, 0x00, 
0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 
0x03, 0x00, 0x0e, 0x00, 0xc1, 0x00, 0xc3, 0x00, 0x0e, 0x81, 0x60, 0x0e, 0x83, 0x00, 0x00, 0x00, 
0x81, 0x00, 0x06, 0x00, 0xc0, 0x00, 0x66, 0x00, 0x06, 0x00, 0x00, 0x06, 0x81, 0x00, 0x00, 0x00, 
0xc0, 0x87, 0xc7, 0xc7, 0xc7, 0xc7, 0x06, 0x67, 0xc6, 0x83, 0x60, 0x66, 0x81, 0xce, 0xcd, 0xc7, 
0x00, 0xc0, 0x66, 0x6c, 0xcc, 0x6c, 0x8f, 0xcc, 0x67, 0x81, 0x60, 0xc6, 0x81, 0xef, 0x66, 0x6c, 
0x00, 0xc7, 0x66, 0x0c, 0xcc, 0xef, 0x06, 0xcc, 0x66, 0x81, 0x60, 0x87, 0x81, 0x6d, 0x66, 0x6c, 
0x00, 0xcc, 0x66, 0x6c, 0xcc, 0x0c, 0x06, 0xc7, 0x66, 0x81, 0x66, 0xc6, 0x81, 0x6d, 0x66, 0x6c, 
0x00, 0x67, 0xcd, 0xc7, 0x67, 0xc7, 0x0f, 0xc0, 0x6e, 0xc3, 0x66, 0x6e, 0xc3, 0x6d, 0x66, 0xc7, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x00, 0x00, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x81, 0x07, 0x67, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x81, 0x81, 0xcd, 0x01, 
0xcd, 0x67, 0xcd, 0xe7, 0xcf, 0xcc, 0x6c, 0x6c, 0x6c, 0x6c, 0xe7, 0x81, 0x81, 0x81, 0x00, 0x83, 
0x66, 0xcc, 0x67, 0x0c, 0x03, 0xcc, 0x6c, 0x6d, 0xc6, 0x6c, 0xc4, 0x07, 0x81, 0xe0, 0x00, 0xc6, 
0x66, 0xcc, 0x06, 0xc7, 0x03, 0xcc, 0x6c, 0x6d, 0x83, 0x6c, 0x81, 0x81, 0x81, 0x81, 0x00, 0x6c, 
0xc7, 0xc7, 0x06, 0x60, 0x63, 0xcc, 0xc6, 0xef, 0xc6, 0xe7, 0x23, 0x81, 0x81, 0x81, 0x00, 0x6c, 
0x06, 0xc0, 0x0f, 0xcf, 0xc1, 0x67, 0x83, 0xc6, 0x6c, 0x60, 0xe7, 0xe0, 0x81, 0x07, 0x00, 0xef, 
0x0f, 0xe1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xc7, 0xcc, 0xc0, 0xc7, 0x6c, 0x03, 0x03, 0x00, 0xc7, 0x6c, 0x03, 0x66, 0xc7, 0x03, 0x6c, 0x83, 
0x6c, 0x00, 0x81, 0x28, 0x00, 0x81, 0x03, 0x00, 0x28, 0x00, 0x81, 0x00, 0x28, 0x81, 0x83, 0xc6, 
0x0c, 0xcc, 0xc7, 0x87, 0x87, 0x87, 0x87, 0xe7, 0xc7, 0xc7, 0xc7, 0x83, 0x83, 0x00, 0xc6, 0xc7, 
0x0c, 0xcc, 0x6c, 0xc0, 0xc0, 0xc0, 0xc0, 0x0c, 0x6c, 0x6c, 0x6c, 0x81, 0x81, 0x83, 0x6c, 0x6c, 
0x6c, 0xcc, 0xef, 0xc7, 0xc7, 0xc7, 0xc7, 0x0c, 0xef, 0xef, 0xef, 0x81, 0x81, 0x81, 0xef, 0xef, 
0xc7, 0xcc, 0x0c, 0xcc, 0xcc, 0xcc, 0xcc, 0xe7, 0x0c, 0x0c, 0x0c, 0x81, 0x81, 0x81, 0x6c, 0x6c, 
0xc0, 0x67, 0xc7, 0x67, 0x67, 0x67, 0x67, 0xc0, 0xc7, 0xc7, 0xc7, 0xc3, 0xc3, 0xc3, 0x6c, 0x6c, 
0x87, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x81, 0x00, 0xe3, 0xc7, 0x6c, 0x03, 0x87, 0x06, 0x6c, 0x6c, 0x6c, 0x81, 0x83, 0x66, 0x8f, 0xe0, 
0x03, 0x00, 0xc6, 0x28, 0x00, 0x81, 0x48, 0x03, 0x00, 0x83, 0x00, 0x81, 0xc6, 0x66, 0xcc, 0xb1, 
0xef, 0xe7, 0xcc, 0xc7, 0xc7, 0xc7, 0x00, 0xcc, 0x6c, 0xc6, 0x6c, 0xe7, 0x46, 0xc3, 0xcc, 0x81, 
0x0c, 0x81, 0xef, 0x6c, 0x6c, 0x6c, 0xcc, 0xcc, 0x6c, 0x6c, 0x6c, 0x0c, 0x0f, 0xe7, 0xaf, 0xc3, 
0x8f, 0xe7, 0xcc, 0x6c, 0x6c, 0x6c, 0xcc, 0xcc, 0x6c, 0x6c, 0x6c, 0x0c, 0x06, 0x81, 0x6c, 0x81, 
0x0c, 0x8d, 0xcc, 0x6c, 0x6c, 0x6c, 0xcc, 0xcc, 0xe7, 0xc6, 0x6c, 0xe7, 0x66, 0xe7, 0xfc, 0x8d, 
0xef, 0xe7, 0xec, 0xc7, 0xc7, 0xc7, 0x67, 0x67, 0x60, 0x83, 0xc7, 0x81, 0xcf, 0x81, 0x6c, 0x07, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x00, 0x00, 0x81, 0x00, 0x81, 0x7c, 0x00, 
0x81, 0xc0, 0xc0, 0x81, 0x67, 0x67, 0xc3, 0x83, 0x81, 0x00, 0x00, 0x36, 0x36, 0x81, 0x00, 0x00, 
0x03, 0x81, 0x81, 0x03, 0xcd, 0xcd, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x6e, 0x6e, 0x00, 0x33, 0xcc, 
0x87, 0x00, 0xc7, 0xcc, 0x00, 0x00, 0xc6, 0xc6, 0x81, 0x00, 0x00, 0xc6, 0xc6, 0x81, 0x66, 0x66, 
0xc0, 0x83, 0x6c, 0xcc, 0xcd, 0x6e, 0xe3, 0x83, 0x81, 0xef, 0xef, 0xe7, 0xa7, 0x81, 0xcc, 0x33, 
0xc7, 0x81, 0x6c, 0xcc, 0x66, 0x6f, 0x00, 0x00, 0x03, 0x0c, 0x60, 0x33, 0x63, 0xc3, 0x66, 0x66, 
0xcc, 0x81, 0x6c, 0xcc, 0x66, 0xed, 0xe7, 0xc7, 0x36, 0x0c, 0x60, 0x66, 0xa6, 0xc3, 0x33, 0xcc, 
0x67, 0xc3, 0xc7, 0x67, 0x66, 0xec, 0x00, 0x00, 0xe3, 0x00, 0x00, 0xcc, 0xfd, 0x81, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x60, 0x00, 0x00, 0x00, 
0x22, 0x55, 0x77, 0x81, 0x81, 0x81, 0x63, 0x00, 0x00, 0x63, 0x63, 0x00, 0x63, 0x63, 0x81, 0x00, 
0x88, 0xaa, 0xdd, 0x81, 0x81, 0x81, 0x63, 0x00, 0x00, 0x63, 0x63, 0x00, 0x63, 0x63, 0x81, 0x00, 
0x22, 0x55, 0x77, 0x81, 0x81, 0x8f, 0x63, 0x00, 0x8f, 0x6f, 0x63, 0xef, 0x6f, 0x63, 0x8f, 0x00, 
0x88, 0xaa, 0xdd, 0x81, 0x81, 0x81, 0x63, 0x00, 0x81, 0x60, 0x63, 0x60, 0x60, 0x63, 0x81, 0x00, 
0x22, 0x55, 0x77, 0x81, 0x8f, 0x8f, 0x6f, 0xef, 0x8f, 0x6f, 0x63, 0x6f, 0xef, 0xef, 0x8f, 0x8f, 
0x88, 0xaa, 0xdd, 0x81, 0x81, 0x81, 0x63, 0x63, 0x81, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00, 0x81, 
0x22, 0x55, 0x77, 0x81, 0x81, 0x81, 0x63, 0x63, 0x81, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00, 0x81, 
0x88, 0xaa, 0xdd, 0x81, 0x81, 0x81, 0x63, 0x63, 0x81, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00, 0x81, 
0x81, 0x81, 0x00, 0x81, 0x00, 0x81, 0x81, 0x63, 0x63, 0x00, 0x63, 0x00, 0x63, 0x00, 0x63, 0x81, 
0x81, 0x81, 0x00, 0x81, 0x00, 0x81, 0x81, 0x63, 0x63, 0x00, 0x63, 0x00, 0x63, 0x00, 0x63, 0x81, 
0x81, 0x81, 0x00, 0x81, 0x00, 0x81, 0xf1, 0x63, 0x73, 0xf3, 0x7f, 0xff, 0x73, 0xff, 0x7f, 0xff, 
0x81, 0x81, 0x00, 0x81, 0x00, 0x81, 0x81, 0x63, 0x03, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
0xf1, 0xff, 0xff, 0xf1, 0xff, 0xff, 0xf1, 0x73, 0xf3, 0x73, 0xff, 0x7f, 0x73, 0xff, 0x7f, 0xff, 
0x00, 0x00, 0x81, 0x81, 0x00, 0x81, 0x81, 0x63, 0x00, 0x63, 0x00, 0x63, 0x63, 0x00, 0x63, 0x00, 
0x00, 0x00, 0x81, 0x81, 0x00, 0x81, 0x81, 0x63, 0x00, 0x63, 0x00, 0x63, 0x63, 0x00, 0x63, 0x00, 
0x00, 0x00, 0x81, 0x81, 0x00, 0x81, 0x81, 0x63, 0x00, 0x63, 0x00, 0x63, 0x63, 0x00, 0x63, 0x00, 
0x63, 0x00, 0x00, 0x63, 0x81, 0x00, 0x00, 0x63, 0x81, 0x81, 0x00, 0xff, 0x00, 0x0f, 0xf0, 0xff, 
0x63, 0x00, 0x00, 0x63, 0x81, 0x00, 0x00, 0x63, 0x81, 0x81, 0x00, 0xff, 0x00, 0x0f, 0xf0, 0xff, 
0x63, 0xff, 0x00, 0x63, 0xf1, 0xf1, 0x00, 0x63, 0xff, 0x81, 0x00, 0xff, 0x00, 0x0f, 0xf0, 0xff, 
0x63, 0x00, 0x00, 0x63, 0x81, 0x81, 0x00, 0x63, 0x81, 0x81, 0x00, 0xff, 0x00, 0x0f, 0xf0, 0xff, 
0xff, 0xff, 0xff, 0xf3, 0xf1, 0xf1, 0xf3, 0xff, 0xff, 0x8f, 0xf1, 0xff, 0xff, 0x0f, 0xf0, 0x00, 
0x00, 0x81, 0x63, 0x00, 0x00, 0x81, 0x63, 0x63, 0x81, 0x00, 0x81, 0xff, 0xff, 0x0f, 0xf0, 0x00, 
0x00, 0x81, 0x63, 0x00, 0x00, 0x81, 0x63, 0x63, 0x81, 0x00, 0x81, 0xff, 0xff, 0x0f, 0xf0, 0x00, 
0x00, 0x81, 0x63, 0x00, 0x00, 0x81, 0x63, 0x63, 0x81, 0x00, 0x81, 0xff, 0xff, 0x0f, 0xf0, 0x00, 
0x00, 0x87, 0xef, 0x00, 0xef, 0x00, 0x00, 0x00, 0xe7, 0x83, 0x83, 0xe0, 0x00, 0x60, 0xe1, 0x00, 
0x00, 0xcc, 0x6c, 0x00, 0x6c, 0x00, 0x00, 0x67, 0x81, 0xc6, 0xc6, 0x81, 0x00, 0xc0, 0x03, 0xc7, 
0x67, 0xcc, 0x0c, 0xef, 0x06, 0xe7, 0x66, 0xcd, 0xc3, 0x6c, 0x6c, 0xc0, 0xe7, 0xe7, 0x06, 0x6c, 
0xcd, 0x8d, 0x0c, 0xc6, 0x03, 0x8d, 0x66, 0x81, 0x66, 0xef, 0x6c, 0xe3, 0xbd, 0xbd, 0xe7, 0x6c, 
0x8c, 0xcc, 0x0c, 0xc6, 0x06, 0x8d, 0x66, 0x81, 0x66, 0x6c, 0xc6, 0x66, 0xbd, 0xbd, 0x06, 0x6c, 
0xcd, 0x6c, 0x0c, 0xc6, 0x6c, 0x8d, 0x66, 0x81, 0xc3, 0xc6, 0xc6, 0x66, 0xe7, 0xe7, 0x03, 0x6c, 
0x67, 0xcc, 0x0c, 0xc6, 0xef, 0x07, 0xc7, 0x81, 0x81, 0x83, 0xee, 0xc3, 0x00, 0x06, 0xe1, 0x6c, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0xe7, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 
0x00, 0x81, 0x03, 0xc0, 0xe0, 0x81, 0x00, 0x00, 0x83, 0x00, 0x00, 0xf0, 0xc6, 0x87, 0x00, 0x00, 
0xef, 0x81, 0x81, 0x81, 0xb1, 0x81, 0x81, 0x67, 0xc6, 0x00, 0x00, 0xc0, 0x63, 0xc0, 0x00, 0x00, 
0x00, 0xe7, 0xc0, 0x03, 0xb1, 0x81, 0x00, 0xcd, 0xc6, 0x00, 0x00, 0xc0, 0x63, 0x81, 0xc3, 0x00, 
0xef, 0x81, 0x81, 0x81, 0x81, 0x81, 0xe7, 0x00, 0x83, 0x81, 0x81, 0xc0, 0x63, 0x03, 0xc3, 0x00, 
0x00, 0x81, 0x03, 0xc0, 0x81, 0x81, 0x00, 0x67, 0x00, 0x81, 0x00, 0xce, 0x63, 0xc7, 0xc3, 0x00, 
0xef, 0x00, 0x00, 0x00, 0x81, 0x8d, 0x81, 0xcd, 0x00, 0x00, 0x00, 0xc6, 0x00, 0x00, 0xc3, 0x00, 
0x00, 0xe7, 0xe7, 0xe7, 0x81, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x81, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x00, 0x00, 0x00};

static const uint32_t quadexpand[] __attribute__((aligned(16))) = {
	0x00000000, 0xFF000000, 0x00FF0000, 0xFFFF0000,
	0x0000FF00, 0xFF00FF00, 0x00FFFF00, 0xFFFFFF00,
	0x000000FF, 0xFF0000FF, 0x00FF00FF, 0xFFFF00FF,
	0x0000FFFF, 0xFF00FFFF, 0x00FFFFFF, 0xFFFFFFFF,
};

static const uint32_t vgapalette[] __attribute__((aligned(16))) = {
	0x00000000, 0x000002aa, 0x0014aa00, 0x0000aaaa, 0x00aa0003, 0x00aa00aa, 0x00aa5500, 0x00aaaaaa, 0x00555555, 0x005555ff, 0x0055ff55, 0x0055ffff, 0x00ff5555, 0x00fd55ff, 0x00ffff55, 0x00ffffff,
	0x00000000, 0x00101010, 0x00202020, 0x00353535, 0x00454545, 0x00555555, 0x00656565, 0x00757575, 0x008a8a8a, 0x009a9a9a, 0x00aaaaaa, 0x00bababa, 0x00cacaca, 0x00dfdfdf, 0x00efefef, 0x00ffffff,
	0x000004ff, 0x004104ff, 0x008203ff, 0x00be02ff, 0x00fd00ff, 0x00fe00be, 0x00ff0082, 0x00ff0041, 0x00ff0008, 0x00ff4105, 0x00ff8200, 0x00ffbe00, 0x00ffff00, 0x00beff00, 0x0082ff00, 0x0041ff01,
	0x0024ff00, 0x0022ff42, 0x001dff82, 0x0012ffbe, 0x0000ffff, 0x0000beff, 0x000182ff, 0x000041ff, 0x008282ff, 0x009e82ff, 0x00be82ff, 0x00df82ff, 0x00fd82ff, 0x00fe82df, 0x00ff82be, 0x00ff829e,
	0x00ff8282, 0x00ff9e82, 0x00ffbe82, 0x00ffdf82, 0x00ffff82, 0x00dfff82, 0x00beff82, 0x009eff82, 0x0082ff82, 0x0082ff9e, 0x0082ffbe, 0x0082ffdf, 0x0082ffff, 0x0082dfff, 0x0082beff, 0x00829eff,
	0x00babaff, 0x00cabaff, 0x00dfbaff, 0x00efbaff, 0x00febaff, 0x00febaef, 0x00ffbadf, 0x00ffbaca, 0x00ffbaba, 0x00ffcaba, 0x00ffdfba, 0x00ffefba, 0x00ffffba, 0x00efffba, 0x00dfffba, 0x00caffbb,
	0x00baffba, 0x00baffca, 0x00baffdf, 0x00baffef, 0x00baffff, 0x00baefff, 0x00badfff, 0x00bacaff, 0x00010171, 0x001c0171, 0x00390171, 0x00550071, 0x00710071, 0x00710055, 0x00710039, 0x0071001c,
	0x00710001, 0x00711c01, 0x00713900, 0x00715500, 0x00717100, 0x00557100, 0x00397100, 0x001c7100, 0x00097100, 0x0009711c, 0x00067139, 0x00037155, 0x00007171, 0x00005571, 0x00003971, 0x00001c71,
	0x00393971, 0x00453971, 0x00553971, 0x00613971, 0x00713971, 0x00713961, 0x00713955, 0x00713945, 0x00713939, 0x00714539, 0x00715539, 0x00716139, 0x00717139, 0x00617139, 0x00557139, 0x0045713a,
	0x00397139, 0x00397145, 0x00397155, 0x00397161, 0x00397171, 0x00396171, 0x00395571, 0x00394572, 0x00515171, 0x00595171, 0x00615171, 0x00695171, 0x00715171, 0x00715169, 0x00715161, 0x00715159,
	0x00715151, 0x00715951, 0x00716151, 0x00716951, 0x00717151, 0x00697151, 0x00617151, 0x00597151, 0x00517151, 0x0051715a, 0x00517161, 0x00517169, 0x00517171, 0x00516971, 0x00516171, 0x00515971,
	0x00000042, 0x00110041, 0x00200041, 0x00310041, 0x00410041, 0x00410032, 0x00410020, 0x00410010, 0x00410000, 0x00411000, 0x00412000, 0x00413100, 0x00414100, 0x00314100, 0x00204100, 0x00104100,
	0x00034100, 0x00034110, 0x00024120, 0x00014131, 0x00004141, 0x00003141, 0x00002041, 0x00001041, 0x00202041, 0x00282041, 0x00312041, 0x00392041, 0x00412041, 0x00412039, 0x00412031, 0x00412028,
	0x00412020, 0x00412820, 0x00413120, 0x00413921, 0x00414120, 0x00394120, 0x00314120, 0x00284120, 0x00204120, 0x00204128, 0x00204131, 0x00204139, 0x00204141, 0x00203941, 0x00203141, 0x00202841,
	0x002d2d41, 0x00312d41, 0x00352d41, 0x003d2d41, 0x00412d41, 0x00412d3d, 0x00412d35, 0x00412d31, 0x00412d2d, 0x0041312d, 0x0041352d, 0x00413d2d, 0x0041412d, 0x003d412d, 0x0035412d, 0x0031412d,
	0x002d412d, 0x002d4131, 0x002d4135, 0x002d413d, 0x002d4141, 0x002d3d41, 0x002d3541, 0x002d3141, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000
};

void VPUSetDefaultPalette(struct EVideoContext *_context)
{
	for (uint32_t i=0; i<256; ++i)
	{
		iowrite32(_context->m_platform->videoio, VPUCMD_SETPAL);
		iowrite32(_context->m_platform->videoio, (i<<24) | vgapalette[i]);
	}
}

void VPUSetVideoMode(struct EVideoContext *_context, const enum EVideoMode _mode, const enum EColorMode _cmode, const enum EVideoScanoutEnable _scanEnable)
{
	if (_context)
	{
		// Store for later
		_context->m_vmode = _mode;
		_context->m_cmode = _cmode;

		// NOTE: Caller sets vmode/cmode fields
		_context->m_scanEnable = _scanEnable;
		_context->m_strideInWords = VPUGetStride(_context->m_vmode, _context->m_cmode) / sizeof(uint32_t);

		VPUGetDimensions(_context->m_vmode, &_context->m_graphicsWidth, &_context->m_graphicsHeight);

		// NOTE: For the time being console is always running at 640x480 mode
		_context->m_consoleWidth = (uint16_t)(_context->m_graphicsWidth/8);
		_context->m_consoleHeight = (uint16_t)(_context->m_graphicsHeight/8);
		_context->m_consoleUpdated = 0;

		iowrite32(_context->m_platform->videoio, VPUCMD_SETVMODE);
		iowrite32(_context->m_platform->videoio, MAKEVMODEINFO((uint32_t)_context->m_cmode, (uint32_t)_context->m_vmode, (uint32_t)_scanEnable));
	}
	else
	{
		// Does not preserve state, mostly preferred during shutdown
		iowrite32(_context->m_platform->videoio, VPUCMD_SETVMODE);
		iowrite32(_context->m_platform->videoio, MAKEVMODEINFO((uint32_t)_cmode, (uint32_t)_mode, (uint32_t)_scanEnable));
	}
}

void VPUSetScanoutAddress(struct EVideoContext *_context, const uint32_t _scanOutAddress64ByteAligned)
{
	_context->m_scanoutAddressCacheAligned = _scanOutAddress64ByteAligned;
	//EAssert((_scanOutAddress64ByteAligned&0x3F) == 0, "Video scanout address has to be aligned to 64 bytes\n");

	iowrite32(_context->m_platform->videoio, VPUCMD_SETVPAGE);
	iowrite32(_context->m_platform->videoio, (uint32_t)_scanOutAddress64ByteAligned);
}

void VPUSetWriteAddress(struct EVideoContext *_context, const uint32_t _cpuWriteAddress64ByteAligned)
{
	_context->m_cpuWriteAddressCacheAligned = _cpuWriteAddress64ByteAligned;
	//EAssert((_writeAddress64ByteAligned&0x3F) == 0, "Video CPU write address has to be aligned to 64 bytes\n");
}

void VPUSetPal(struct EVideoContext *_context, const uint8_t _paletteIndex, const uint32_t _red, const uint32_t _green, const uint32_t _blue)
{
	iowrite32(_context->m_platform->videoio, VPUCMD_SETPAL);
	iowrite32(_context->m_platform->videoio, (_paletteIndex<<24) | (MAKECOLORRGB24(_red, _green, _blue)));
}

void VPUClear(struct EVideoContext *_context, const uint32_t _colorWord)
{
	uint32_t *vramBase = (uint32_t*)_context->m_cpuWriteAddressCacheAligned;
	uint32_t W = _context->m_graphicsHeight * _context->m_strideInWords;
	for (uint32_t i=0; i<W; ++i)
		vramBase[i] = _colorWord;
}

uint32_t VPUReadVBlankCounter(struct EVideoContext *_context)
{
	// vblank counter lives at this address
	return ioread32(_context->m_platform->videoio) & 0x1;
}

uint32_t VPUGetScanline(struct EVideoContext *_context)
{
	return (ioread32(_context->m_platform->videoio) & 0x7FE) >> 1;
}

void VPUSwapPages(struct EVideoContext* _context, struct EVideoSwapContext *_sc)
{
	_sc->readpage = ((_sc->cycle)%2) ? _sc->framebufferA->dmaAddress : _sc->framebufferB->dmaAddress;
	_sc->writepage = ((_sc->cycle)%2) ? _sc->framebufferB->cpuAddress : _sc->framebufferA->cpuAddress;
	VPUSetWriteAddress(_context, (uint32_t)_sc->writepage);
	VPUSetScanoutAddress(_context, (uint32_t)_sc->readpage);
	_sc->cycle = _sc->cycle + 1;
}

void VPUWaitVSync(struct EVideoContext *_context)
{
	volatile uint32_t prevvsync = VPUReadVBlankCounter(_context);
	volatile uint32_t currentvsync;
	do {
		currentvsync = VPUReadVBlankCounter(_context);
	} while (currentvsync == prevvsync);
}

void VPUPrintString(struct EVideoContext *_context, const uint8_t _foregroundIndex, const uint8_t _backgroundIndex, const uint16_t _x, const uint16_t _y, const char *_message, int _length)
{
	uint32_t *vramBase = (uint32_t*)_context->m_cpuWriteAddressCacheAligned;
	uint32_t stride = _context->m_strideInWords;
	uint32_t FG = (_foregroundIndex<<24) | (_foregroundIndex<<16) | (_foregroundIndex<<8) | _foregroundIndex;
	uint32_t BG = (_backgroundIndex<<24) | (_backgroundIndex<<16) | (_backgroundIndex<<8) | _backgroundIndex;

	// Align to 4 pixels
	uint16_t cx = _x&0xFFFC;
	// Y is aligned to 1 pixel
	uint16_t cy = _y;

	for (int i=0; i<_length; ++i)
	{
		int currentchar = _message[i];
		if (currentchar<32)
			continue;

		int charrow = (currentchar>>4)*8;
		int charcol = (currentchar%16);
		for (int y=0; y<8; ++y)
		{
			int yoffset = (cy*8+y)*stride;
			// Expand bit packed character row into individual pixels
			uint8_t chardata = residentfont[charcol+((charrow+y)*16)];
			// Output the 2 words (8 pixels) for this row
			for (int x=0; x<2; ++x)
			{
				// X offset in words
				int xoffset = cx + x;
				// Generate foreground / background output via masks
				// Note that the nibbles of the font bytes are flipped for this to work
				uint32_t mask = quadexpand[chardata&0x0F];
				uint32_t invmask = ~mask;
				uint32_t fourPixels = (mask & FG) | (invmask & BG);
				// Output the combined 4-pixel value
				vramBase[xoffset + yoffset] = fourPixels;
				// Move to the next set of 4 pixels
				chardata = chardata >> 4;
			}
		}
		// Next char position (2 words)
		cx+=2;
	}
}

void VPUConsoleResolve(struct EVideoContext *_context)
{
	uint32_t *vramBase = (uint32_t*)_context->m_cpuWriteAddressCacheAligned;
	uint8_t *characterBase = character_buffer;
	uint8_t *colorBase = color_buffer;
	uint32_t stride = _context->m_strideInWords;
	const uint16_t H = _context->m_consoleHeight;
	const uint16_t W = _context->m_consoleWidth;

	for (uint16_t cy=0; cy<H; ++cy)
	{
		for (uint16_t cx=0; cx<W; ++cx)
		{
			int currentchar = characterBase[cx+cy*W];
			if (currentchar<32)
				continue;

			uint8_t currentcolor = colorBase[cx+cy*W];
			uint32_t BG = (currentcolor>>4)&0x0F;
			BG = (BG<<24) | (BG<<16) | (BG<<8) | BG;
			uint32_t FG = currentcolor&0x0F;
			FG = (FG<<24) | (FG<<16) | (FG<<8) | FG;

			int charrow = (currentchar>>4)*8;
			int charcol = (currentchar%16);
			for (int y=0; y<8; ++y)
			{
				int yoffset = (cy*8+y)*stride;
				// Expand bit packed character row into individual pixels
				uint8_t chardata = residentfont[charcol+((charrow+y)*16)];
				// Output the 2 words (8 pixels) for this row
				for (int x=0; x<2; ++x)
				{
					// X offset in words
					int xoffset = cx*2 + x;
					// Generate foreground / background output via masks
					// Note that the nibbles of the font bytes are flipped for this to work
					uint32_t mask = quadexpand[chardata&0x0F];
					uint32_t invmask = ~mask;
					uint32_t fourPixels = (mask & FG) | (invmask & BG);
					// Output the combined 4-pixel value
					vramBase[xoffset + yoffset] = fourPixels;
					// Move to the next set of 4 pixels
					chardata = chardata >> 4;
				}
			}
		}
	}

	// Show caret if it's in the visible state
	if (_context->m_caretBlink)
	{
		int cx = _context->m_caretX;
		int cy = _context->m_caretY;
		uint32_t yoffset = (cy*8+7)*stride; // Last row of the character
		uint32_t xoffset = cx*2; // 2 words per character
		uint32_t *caret = &vramBase[xoffset + yoffset];
		uint32_t FG = CONSOLEDIMGREEN;

        if (_context->m_caretType == 0)
        {
    		FG = (FG<<24) | (FG<<16) | (FG<<8) | FG;
		    // Regular cursor is 8 pixels wide, 2 pixels high
		    *caret = FG;
		    *(caret+1) = FG;
		    caret -= stride;
		    *caret = FG;
		    *(caret+1) = FG;
        }
        else
        {
            // Insert cursor shows differently and is taller
            FG = (FG<<8) | FG;
		    *caret |= FG;
		    caret -= stride;
		    *caret |= FG;
		    caret -= stride;
		    *caret |= FG;
		    caret -= stride;
		    *caret |= FG;
		    caret -= stride;
		    *caret |= FG;
		    caret -= stride;
		    *caret |= FG;
		    caret -= stride;
		    *caret |= FG;
		    caret -= stride;
		    *caret |= FG;
        }
    }

	_context->m_consoleUpdated = 0;
}

void VPUConsoleScrollUp(struct EVideoContext *_context)
{
	const uint16_t W = _context->m_consoleWidth;
	const uint16_t H_1 = _context->m_consoleHeight - 1;

	// We're trying to write past end of console; scroll up the contents of the console
	// NOTE: This does not save the contents of the text buffer that has scrolled off
	uint8_t* targettext = character_buffer;
	uint8_t* targetcolor = color_buffer;
	uint8_t* sourcetext = character_buffer + W;
	uint8_t* sourcecolor = color_buffer + W;
	uint8_t* lasttextrow = character_buffer + W*H_1;
	uint8_t* lastcolorrow = color_buffer + W*H_1;
	__builtin_memcpy((void*)targettext, (void*)sourcetext, W*H_1);
	__builtin_memcpy((void*)targetcolor, (void*)sourcecolor, W*H_1);
	// Fill last row with spaces
	__builtin_memset((void*)lasttextrow, 0x20, W);
	// Fill last row with default background
	__builtin_memset((void*)lastcolorrow, (CONSOLEDEFAULTBG<<4) | (CONSOLEDEFAULTFG), W);
}

void VPUConsoleSetColors(struct EVideoContext *_context, const uint8_t _foregroundIndex, const uint8_t _backgroundIndex)
{
	_context->m_consoleColor = ((_backgroundIndex&0x0F)<<4) | (_foregroundIndex&0x0F);
}

void VPUConsoleClear(struct EVideoContext *_context)
{
	uint8_t *characterBase = character_buffer;
	uint8_t *colorBase = color_buffer;
	// Fill console with spaces
	__builtin_memset(characterBase, 0x20, _context->m_consoleWidth*_context->m_consoleHeight);
	__builtin_memset(colorBase, _context->m_consoleColor, _context->m_consoleWidth*_context->m_consoleHeight);
	_context->m_consoleUpdated = 1;
	_context->m_cursorX = 0;
	_context->m_cursorY = 0;

	//UARTPrintf("\033[2J");
}

void VPUConsolePrintInPlace(struct EVideoContext *_context, const char *_message, int _length)
{
	uint8_t *characterBase = character_buffer;
	uint8_t *colorBase = color_buffer;
	uint32_t stride = _context->m_consoleWidth;
	int cx = _context->m_cursorX;
	int cy = _context->m_cursorY;
	const uint16_t W = _context->m_consoleWidth;
	const uint16_t H_1 = _context->m_consoleHeight - 1;
	uint8_t currentcolor = _context->m_consoleColor;

	int i=0;
	int isNotTab = 1;
	while (_message[i] != 0 && i<_length)
	{
		int currentchar = _message[i];

		if (currentchar == '\n') // Line feed moves to the next line
		{
			cx = 0; // We assume carriage return here as well as line feed
			cy++;
		}
		else if (currentchar == '\t') // Tab steps 4 places without touching the text
		{
			cx += 4; // Based on DOS console tab width
			// NOTE: This is not supposed to trigger any behavior except wrap around on same line
			isNotTab = 0;
		}
		else if (currentchar == '\r') // Carriage return rewinds to top of line
		{
			cx=0;
		}
		else
		{
			characterBase[cy*stride+cx] = currentchar;
			colorBase[cy*stride+cx] = currentcolor;
			cx++;
		}

		if (cx >= W)
		{
			cx = 0;
			cy += isNotTab; // TAB won't wrap to next line, it's just walks between tap stops on current line
		}

		if (cy > H_1) // Going off the screen will make us abort
            break;

		++i;
	}

	_context->m_consoleUpdated = 1;
}

void VPUConsolePrint(struct EVideoContext *_context, const char *_message, int _length)
{
	uint8_t *characterBase = character_buffer;
	uint8_t *colorBase = color_buffer;
	uint32_t stride = _context->m_consoleWidth;
	int cx = _context->m_cursorX;
	int cy = _context->m_cursorY;
	const uint16_t W = _context->m_consoleWidth;
	const uint16_t H_1 = _context->m_consoleHeight - 1;
	uint8_t currentcolor = _context->m_consoleColor;

	int i=0;
	int isNotTab = 1;
	while (_message[i] != 0 && i<_length)
	{
		int currentchar = _message[i];

		if (currentchar == '\n') // Line feed moves to the next line
		{
			cx = 0; // We assume carriage return here as well as line feed
			cy++;
		}
		else if (currentchar == '\t') // Tab steps 4 places without touching the text
		{
			cx += 4; // Based on DOS console tab width
			// NOTE: This is not supposed to trigger any behavior except wrap around on same line
			isNotTab = 0;
		}
		else if (currentchar == '\r') // Carriage return rewinds to top of line
		{
			cx=0;
		}
		else
		{
			characterBase[cy*stride+cx] = currentchar;
			colorBase[cy*stride+cx] = currentcolor;
			cx++;
		}

		if (cx >= W)
		{
			cx = 0;
			cy += isNotTab; // TAB won't wrap to next line, it's just walks between tap stops on current line
		}

		if (cy > H_1)
		{
			VPUConsoleScrollUp(_context);
			cy = H_1;
			//UARTPrintf("\033[M");
		}

		++i;
	}
	_context->m_cursorX = cx;
	_context->m_cursorY = cy;
	_context->m_consoleUpdated = 1;

	//UARTPrintf("%s", _message);
}

void VPUGetDimensions(const enum EVideoMode _mode, uint32_t *_width, uint32_t *_height)
{
	*_width = _mode == EVM_640_Wide ? 640 : 320;
	*_height = _mode == EVM_640_Wide ? 480 : 240;
}

uint32_t VPUGetStride(const enum EVideoMode _mode, const enum EColorMode _cmode)
{
    uint32_t stride = 0;
    if (_cmode == ECM_8bit_Indexed)
        stride = _mode == EVM_320_Wide ? 3 : 5;
    else
        stride = _mode == EVM_320_Wide ? 5 : 10;

    return stride * 128;
}

void VPUConsoleMoveCursor(struct EVideoContext *_context, int dx, int dy)
{
 	const uint16_t W = _context->m_consoleWidth;
     const uint16_t W_1 = _context->m_consoleWidth - 1;
	const uint16_t H_1 = _context->m_consoleHeight - 1;

     int cx = _context->m_cursorX + dx;
     int cy = _context->m_cursorY + dy;

    if (cx >= W)
    {
        cx = 0;
        ++cy;
    }

    if (cx < 0)
    {
        if (cy == 0)
            cx = 0;
        else
        {
            cx = W_1;
            --cy;
        }
    }

    if (cy < 0)
    {
        cy = 0;
    }

    if (cy > H_1)
    {
        VPUConsoleScrollUp(_context);
        cy = H_1;
    }

    _context->m_cursorX = cx;
    _context->m_cursorY = cy;
}

void VPUConsoleHomeCursor(struct EVideoContext *_context)
{
	_context->m_cursorX = 0;
}

void VPUConsoleEndCursor(struct EVideoContext *_context)
{
    uint8_t *characterBase = character_buffer;
    uint32_t stride = _context->m_consoleWidth;
    const uint16_t W_1 = _context->m_consoleWidth - 1;

    for (uint16_t i=W_1; i!=0; i--)
    {
        if (characterBase[_context->m_cursorY*stride+i] != ' ')
        {
            _context->m_cursorX = i+1;
            if (_context->m_cursorX > W_1)
                _context->m_cursorX = W_1;
            return;
        }
    }
}

void VPUConsoleCopyLine(struct EVideoContext *_context, uint16_t _line, uint16_t _xStart, uint16_t _xEnd, char *_buffer)
{
	uint8_t *characterBase = character_buffer;
	uint32_t stride = _context->m_consoleWidth;
	uint16_t cy = _line == VPU_AUTO ? _context->m_cursorY : _line;

    int i = 0;
	for (uint16_t cx=_xStart; cx<_xEnd; ++cx)
		_buffer[i++] = characterBase[cy*stride+cx];
    _buffer[i] = 0;
}

int VPUConsoleFillLine(struct EVideoContext *_context, const char _character)
{
	uint8_t *characterBase = character_buffer;
	uint8_t *colorBase = color_buffer;
	uint32_t stride = _context->m_consoleWidth;
	const uint16_t H_1 = _context->m_consoleHeight-1;
	const uint16_t W = _context->m_consoleWidth;
	uint8_t currentcolor = _context->m_consoleColor;

	int cy = _context->m_cursorY;
	int numchars = W - _context->m_cursorX;
	for (uint16_t cx=_context->m_cursorX; cx<W; ++cx)
	{
		characterBase[cy*stride+cx] = _character;
		colorBase[cy*stride+cx] = currentcolor;
	}
	_context->m_cursorX = 0;
	_context->m_cursorY++;

	if (_context->m_cursorY > H_1)
	{
		VPUConsoleScrollUp(_context);
		_context->m_cursorY = H_1;
		//UARTPrintf("\033[M");
	}

	_context->m_consoleUpdated = 1;

	return numchars;
}

void VPUInsertCharacter(struct EVideoContext *_context, uint16_t _x, uint16_t _y, uint8_t _character)
{
	uint8_t *characterBase = character_buffer;
	uint8_t *colorBase = color_buffer;
    uint32_t stride = _context->m_consoleWidth;
    const uint16_t W_1 = _context->m_consoleWidth - 1;

    for (uint16_t x=W_1; x!=_x; x--)
    {
        characterBase[_y*stride+x] = characterBase[_y*stride+x-1];
        colorBase[_y*stride+x] = colorBase[_y*stride+x-1];
    }

    characterBase[_y*stride+_x] = _character;
    colorBase[_y*stride+_x] = _context->m_consoleColor;
}

void VPURemoveCharacter(struct EVideoContext *_context, uint16_t _x, uint16_t _y)
{
	uint8_t *characterBase = character_buffer;
	uint8_t *colorBase = color_buffer;
	uint32_t stride = _context->m_consoleWidth;
	const uint16_t W = _context->m_consoleWidth;

	for (uint16_t x=_x; x<W; x++)
	{
		if (x+1 < W)
		{
			characterBase[_y*stride+x] = characterBase[_y*stride+x+1];
			colorBase[_y*stride+x] = colorBase[_y*stride+x+1];
		}
		else
		{
			characterBase[_y*stride+x] = ' ';
			colorBase[_y*stride+x] = _context->m_consoleColor;
		}
	}
}

void VPUInitVideo(struct EVideoContext* _context, struct  SPPlatform* _platform)
{
	_context->m_platform = _platform;

	color_buffer = (uint8_t*)malloc(640*480+128);
	character_buffer = (uint8_t*)malloc(640*480+128);
}

void VPUShutdownVideo()
{
	free(character_buffer);
	free(color_buffer);
}
